/********************************************************************************
 * Л А Б О Р А Т О Р Н А Я   Р А Б О Т А  №3  З А   3   С Е М Е С Т Р   С  +  + *
 *------------------------------------------------------------------------------*
 * Project Type  : Win64 Console Application                                    *
 * Project Name  : Tree                                                         *
 * File Name     : Дерево. CPP                                                  *
 * Programmer(s) : Викулов Д.Г.                                                 *
 * Modifyed By   :                                                              *
 * Created       : 31/10/22                                                     *
 * Last Revision : 11/11/22                                                     *
 * Comment(s)    : Реализация операций над бинарными деревьями поиска: вставка, *
 *                 удаление, поиск элемента, обход дерева, вывод дерева на      *
 *                 экран, нахождение высоты, количества узлов дерева. Подсчёт   *
 *                 суммы длин путей от корня до каждого из узлов, содержащих    *
 *                 чётные числа                                                 *
 ********************************************************************************/

#include <iostream>        // стандартные потоки ввода/вывода
#include <iomanip>         // библиотека с модификатором setw
#include <time.h>          // библиотека с модификатором srand
using namespace std;       // используем пространство имён std

/*******************************************************************/
/*            Г Л О Б А Л Ь Н Ы Е   К О Н С Т А Н Т Ы              */
/*******************************************************************/

const int rand_max = 100;        // максимальный случайный элемент, который может попасться в дереве

/*******************************************************************/
/*            Г Л О Б А Л Ь Н Ы Е   П Е Р Е М Е Н Н Ы Е            */
/*******************************************************************/

struct Node                      // структура узла дерева
{
	int Data;                    // информация, хранящаяся в узле
	Node* leftNode;              // адрес на структуру узла левого потомка
	Node* rightNode;             // адрес на структуру узла правого потомка
};

/*******************************************************************/
/*              П Р О Т О Т И П Ы    Ф У Н К Ц И Й                 */
/*******************************************************************/

// печать начальных условий для выбора функции
void pechatusloviy();             // функция не принимает ничего, т. к. просто идёт печать

// печать сформированного массива в таблице
void pechat_tabl(int* pznachenue  // указатель на первый элемент динамического массива-вектора 
	           , int number);     // количество элементов в массиве-векторе

// создание динамического массива - вектора
void sozdanie(int** pznachenue    // адрес указателя на динамический массив-вектор, для изменения значения указателя 
	        , int& number);       // количество элементов в массиве-векторе для изменения
	
// заполнение динамическго массива-вектора
void zapolnenie(int* pznachenue   // указатель на первый элемент динамического массива-вектора 
	          , int number);      // количество элементов в массиве-векторе

// удаление динамического массива - вектора
void udalenie(int* pznachenue);   // указатель на первый элемент динамического массива-вектора

// промежуточная работы с бинарным деревом
void MENU(int* pznachenue         // указатель на первый элемент динамического массива-вектора
	    , Node* Root              // указатель на очередной узел дерева
	    , int number              // количество элементов в массиве-векторе
	    , int vubor);             // номер функции из таблички, выбранной пользователем

// вставка узла в дерево
void Node_insertion(int uzel      // число, которое мы хотим добавить в дерево
	              , Node*& Root); // ссылка на указатель на очередной узел дерева, для изменения дерева

// поиск узла в дереве
void Node_search(int uzel         // число, которое мы хотим найти в дереве
	           , Node* Root);     // указатель на очередной узел дерева

// удаление узла из дерева
void Deleting_a_Node(int uzel     // число, которое мы хотим удалить из дерева
	               , Node* Root); // указатель на очередной узел дерева

// удаление всего дерева в целом
void Deliting_a_Tree(Node* Root); // указатель на очередной узел дерева

// функция прямого обхода дерева
void Tree_traversal_straight(Node* Root);  // указатель на очередной узел дерева

// функция обратного обхода дерева
void Tree_traversal_back(Node* Root);      // указатель на очередной узел дерева

// функция симметричного обхода дерева
void Tree_traversal_symmetric(Node* Root);  // указатель на очередной узел дерева

// печать дерева на экран
void Tree_output(Node* Root       // указатель на очередной узел дерева
	           , int level);      // глубина печати очередного элемента

// печать дерева после поиска с подсвечиванием элемента, который нашли
void Tree_output_search(Node* Root // указатель на очередной узел дерева
	                  , int level  // глубина печати очередного элемента
	                  , int node); // узел, который подсвечиваем

// Рекурсивная функция для вычисления высоты заданного бинарного дерева
int Tree_height(Node* Root);       // указатель на очередной узел дерева

// подсчёт числа узлов в дереве
int Number_of_Nodes(Node* Root);   // указатель на очередной узел дерева  

// подсчёт длин путей от корня до очередного чётного элемента
void Ways_of_even(Node* Root       // указатель на очередной узел дерева  
	            , int dlina        // длина пути от корня до очередного чётного элемента
	            , int& summa_dlin);// сумма длин путей от корня до чётных элементов


/**************************************************************/
/*            О С Н О В Н А Я   П Р О Г Р А М М А             */
/**************************************************************/
int main()
{
	system("color F0");                      // делаем консоль светлой
	setlocale(LC_ALL, "Rus");                // подключаем русский язык
	system("cls");                           // чистим консоль перед выводом
	cout << "\t\t\t \x1b[35mР А Б О Т А   С   Б И Н А Р Н Ы М И   Д Е Р Е В Ь Я М И   П О И С К А\x1b[30m\n\n";
	int number = 0;                          // длина динамического массива-вектора
	int vubor;                               // номер функции из таблицы, выбранной пользователем
	int i;                                   // для цикла создания первоначального дерева только из элементов динамического массива
	int* pznachenue = NULL;                  // указатель на динамический массив целых чисел
	pechatusloviy();                         // вывод функции печати условий
	cout << "\nВыберете функцию: 1 - 10, где 9 - повторение программы с другими числами в массиве, а 10 - выход \n";
	cout << "Вы ввели: "; 
	cin >> vubor;                            // ввод выбора действия над деревом пользователем
	cout << endl;
	if (!cin.good())                         // если при выборе действия ввели не число
	{// выход по ошибке
		cout << "Введённый элемент не является целым числом!!!";
		cout << "\n\n\t\t\t\t\tЗ А В Е Р Ш Е Н И Е   П Р О Г Р А М М Ы \n\n";
		system("pause");
		return 1;                            // закончили программу по ошибке 
	}// if (!cin.good())
	sozdanie(&pznachenue, number);           // создали динамический массив с регулируемым числом элементов
	zapolnenie(pznachenue, number);          // заполнили динамический массив случайными числами
	pechat_tabl(pznachenue, number);         // распечатали заполненный массив в скобках
	Node* Root = NULL;                       // изначально нет дерева - корень нулевой
	for (i = 0; i < number; i++)             // прошли по всем элементам массива
	{
		Node_insertion(pznachenue[i], Root); // добавляем очередной элемент массива в дерево
	}// for i
	// бесконечный цикл выбора до момента пока пользователь не выберет Exit или не ошибётся.
	while (true)
	{
		if (vubor == 9)                      // если пользователь выбрал Repeat
		{
			cout << "\t\t\t\t\t\x1b[31mНачинаем построение массива с другими числами!!!\x1b[30m\n\n";
			system("pause");
			system("cls");                   // чистим экран
			udalenie(pznachenue);            // удаляем ранее созданный массив
			Deliting_a_Tree(Root);           // удяляем ранее заполненное дерево
			cout << "\t\t\t \x1b[35mР А Б О Т А   С   Б И Н А Р Н Ы М И   Д Е Р Е В Ь Я М И   П О И С К А\x1b[30m\n\n";
			pechatusloviy();                 // экран чистый, поэтому печатаем ещё раз таблицу выбора
			cout << "\nВыберете функцию: 1 - 10, где 9 - повторение программы с другими числами в массиве, а 10 - выход \n";
			cin >> vubor;                    // ввод выбора действия над деревом
			cout << endl;
			if (!cin.good())                 // если количество элементов не число
			{// выход по ошибке
				cout << "Введённый элемент не является целым числом или находится вне диапазона";
				cout << "\n\n\t\t\t\t\tЗ А В Е Р Ш Е Н И Е   П Р О Г Р А М М Ы \n\n";
				system("pause");
				return 1;                    // закончили программу по ошибке
			}// if (!cin.good())
			sozdanie(&pznachenue, number);   // создали новый динамический массив с регулируемым числом элементов
			zapolnenie(pznachenue, number);  // заново его заполнили
			pechat_tabl(pznachenue, number); // снова распечатали новый заполненный динамический массив
			Root = NULL;                     // опять нет дерева - корень нулевой, иначе узел не создастся
			for (i = 0; i < number; i++)     // прошли по всем элементам нового массива
			{
				// добавляем очередной элемент нового массива в дерево
				Node_insertion(pznachenue[i], Root);
			}// for i
			continue;                        // запускаем цикл заново  
		}//if (vubor == 9)
		// перешли к выполнению очередной операции над деревом
		MENU(pznachenue, Root, number, vubor);
		// отработали операцию - начинаем другую
		cout << "\t\t\t\t\x1b[31mНачинаем работу с другими функциями для бинарного дерева поиска!!!\x1b[30m\n\n";
		system("pause"); 
		system("cls");                       // чистим экран
		cout << "\t\t\t \x1b[35mР А Б О Т А   С   Б И Н А Р Н Ы М И   Д Е Р Е В Ь Я М И   П О И С К А\x1b[30m\n\n";
		cout << "Количество элементов в массиве: " << number << endl;
		pechatusloviy();                     // экран очищен - заново выводи табличку для выбора новой операции
		cout << "\nВыберете функцию: 1 - 10, где 9 - повторение программы с другими числами в массиве, а 10 - выход \n";
		cout << "Вы ввели: ";
		cin >> vubor;                        // ввод выбора новой операции над деревом пользователем
		pechat_tabl(pznachenue, number);     // снова распечатали массив после очистки экрана
	}// while (true)
	return(0);
}// main()


/*-----------------------------------------------------------*/
/* печать условий для выбора функции */
/*-----------------------------------*/
void pechatusloviy()
{
	// Выводим условия в таблице
	setlocale(0, "C");                       // отключаем русский язык
	cout << char(218) << setw(40) << setfill((char)196) << (char)191 << endl << (char)179;  // выводим верхнюю строку шапки
	setlocale(LC_ALL, "Rus");                // подключаем русский язык
	cout << "   Выберите действие над деревом:      ";
	setlocale(0, "C");                       // отключаем русский язык
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)194 << setw(35) << setfill((char)196) << (char)180 << setfill(' ') << endl << (char)179;    // выводим нижнюю строку шапки с разделителем между номером и названием алгоритма
	cout << "  1." << (char)179 << "  Node_insertion                  ";                                                                                                         // выводим условия выбора и нижнюю с боковыми строчками таблицы
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  2." << (char)179 << "  Node_search                     ";
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  3." << (char)179 << "  Deleting_a_Node                 ";
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  4." << (char)179 << "  Tree_traversal                  ";
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  5." << (char)179 << "  Tree_output                     ";
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  6." << (char)179 << "  Tree_height                     ";
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  7." << (char)179 << "  Number_of_Nodes                 ";
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  8." << (char)179 << "  Ways_of_even                    ";
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  9." << (char)179 << "  Repeat with other numbers       ";
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << " 10." << (char)179 << "  Exit.                           ";
	cout << (char)179 << endl << (char)192 << setw(5) << setfill((char)196) << (char)193 << setw(35) << setfill((char)196) << (char)217 << endl;
	setlocale(LC_ALL, "Rus");               // подключаем русский язык
	return;                                 // возвращаем обещанное значение
}// pechatusloviy()

/*-----------------------------------------------------------*/
/* печать сформированного массива в таблице */
/*------------------------------------------*/
void pechat_tabl(int* pznachenue  // указатель на первый элемент динамического массива-вектора 
	           , int number)      // количество элементов в массиве-векторе
{
	int j;                        // для прохода по элементам массива
	cout << "\t\t\t\t \x1b[33mЦ Е Л О Ч И С Л Е Н Н Ы Й   М А С С И В   З Н А Ч Е Н И Й:\x1b[30m \n";
	setlocale(0, "C");            // выводим массив в красивых скобках
	cout << (char)218 << (char)196 << (char)196 << setw(30) << setfill(' ') << (char)196 << (char)196 << (char)191;          // вывод верхних квадратных скобок
	for (j = 0; j < number; j++)  // идем по всем элементам массива, используя адресную арифметику
	{// выводим элемент массива
		cout << "\n" << char(179) << setw(17) << setfill(' ') << *(pznachenue + j) << setw(17) << setfill(' ') << char(179) << setw(6) << setfill(' ') << "n = " << j + 1;
	}// for j
	cout << '\n';
	cout << (char)192 << (char)196 << (char)196 << setw(30) << setfill(' ') << (char)196 << (char)196 << (char)217 << endl;  // вывод нижних квадратных скобок
	setlocale(LC_ALL, "Rus");     // подключаем русский язык
}//pechat_tabl()


/*-----------------------------------------------------------*/
/* создание динамического массива           */
/*------------------------------------------*/
void sozdanie(int** pznachenue    // адрес указателя на динамический массив-вектор, для изменения значения указателя
	        , int& number)        // количество элементов в массиве-векторе для изменения              
{
	cout << "Введите количество элементов дерева: ";
	cin >> number;                // размер массива, введённый пользователем
	cout << endl;
	if (!cin.good())              // если количество элементов не число
	{// выход по ошибке
		cout << "Введённое количество элементов не является целым числом или вне диапазона!!!";
		cout << "\n\t\t\t\t\tЗ А В Е Р Ш Е Н И Е   П Р О Г Р А М М Ы \n\n";
		system("pause");
		exit(1);                  // закончили программу из функции
	}//if (!cin.good())
	*pznachenue = new int[number];// ввели количество элементов целое число - создали массив на нужное количество элементов
	return;                       // создали - вышли. Вернули обещанное значение в caller
}//sozdanie()


/*-----------------------------------------------------------*/
/*  заполнение динамическго массива - вектора  */
/*---------------------------------------------*/
void zapolnenie(int* pznachenue   // указатель на первый элемент динамического массива-вектора 
	, int number)       // количество элементов в массиве-векторе          
{
	int i = 0;                        // для цикла заполнения
	int j;                            // для цикла заполнения
	int sluch;                        // очередное случайное число, которое мы хотим добавить в массив
	bool flag = true;                 // флаг повторения элемента в массиве
	srand(time(NULL));                // базовое значение генератора псевдослучайных чисел, чтобы rand выдавал не одно и то же значение при разных вызовах
	while(i<number)                   // идём по всем элементам массива
	{
		sluch = rand() % rand_max;    // новое случайное число, которое мы хотим добавить в массив
		// идём по всем элементам массива до i-го с целью выяснения повторов
		for (j = 0; j < i; j++)
		{
			// если новое созданное случайное число совпало с одним из элементов массива до i-го
			if (sluch == pznachenue[j])
			{
				flag = false;         // поменяли значение флага добавления очередного элемента
			}// if (sluch == pznachenue[j])
		}// for j
		
		 // если не sluch не совпал ни с одним из элементов массива
		if (flag)
		{
			pznachenue[i] = sluch;    // помещаем его в массив
			i = i + 1;                // сдвигаемся по массиву
		}//if (flag)

		flag = true;                  // если sluch совпал с очередным элементом массива, то не сдвигаемся, но переводим флаг в исходное состояние
		                              // создаём новый sluch-кандидат
	}// while(i<number)
	return;                           // заполнили - вернулись в caller
}// zapolnenie()


/*-----------------------------------------------------------*/
/* удаление динамического массива           */
/*------------------------------------------*/
void udalenie(int* pznachenue)                     // указатель на первый элемент динамического массива-вектора
{
	delete[] pznachenue;                           // удалили динамический массив-вектор
	return;                                        // возвращаем обещанное значение в caller
}// udalenie()


/*-----------------------------------------------------------*/
/*  промежуточная работы с бинарным деревом    */
/*---------------------------------------------*/
void MENU(int* pznachenue         // указатель на первый элемент динамического массива-вектора
	    , Node* Root              // указатель на очередной узел дерева
	    , int number              // количество элементов в массиве-векторе
	    , int vubor)              // номер функции из таблички, выбранной пользователем
{
	int level = 0;                // глубина печати очередного элемента    
	int high;                     // для хранения значения высоты дерева
	int stop = 1;                 // флаг остановки
	int dlina = 0;                // изначальная длина от корня до очерного чётного элемента
	int uzel;                     // число, введённое пользователем, которое мы хотим добавить в дерево
	int summa_dlin = 0;           // сумма длин путей от корня до очередного чётного элемента в дереве
	cout << "\n\n\t\t\t\t\t\t \x1b[34m ИСХОДНОЕ ДЕРЕВО: \x1b[30m \n";
	Tree_output(Root, level);     // вывод дерева до его изменения
	// функция в зависимости от выбора операции пользователем
	switch(vubor)
	{
		case 1:                   // выбор добавления элемента в дерево
			// бесконечный цикл добавления нового узла в дерево
			while (true)
			{
				cout << "\nЕсли вы не хотите больше добавлять узлы, введите 0: ";
				cin >> stop;      // флаг остановки введен пользователем
				// если пользователь ввёл 0 - флаг остановки добавления
				if (stop == 0)
				{
					break;        // прервали цикл добавления
				}// if (stop == 0)

				cout << "\x1b[32mКакой узел вы хотите добавить в дерево. Введите число, отличное от других в данном массиве:\x1b[30m ";
				cin >> uzel;      // ввели значение узла, который хотим создать
				// эхо-печать
				cout << "Вы ввели " << uzel << endl; 
				// вызвали функцию добавления нового узла в дерево
				Node_insertion(uzel, Root);
			}// while (true)
			// распечатали дерево, чтобы убедиться, что элемент/элементы были добавлено в дерево
			cout << "\t\t\t\t\t\t \x1b[34m ДЕРЕВО ПОСЛЕ ДОБАВЛЕНИЯ ЭЛЕМЕНТОВ: \x1b[30m \n";
			Tree_output(Root, level);
			break;

		case 2:                    // выбор поска элемента в дерева
			// бесконечный цикл поиска узла в дереве
			while (true)
			{
				cout << "\nЕсли вы не хотите больше искать узлы, введите 0: ";
				cin >> stop;       // флаг остановки введен пользователем
				// если пользователь ввёл 0 - флаг остановки поиска
				if (stop == 0)
				{
					break;         // прервали цикл поиска
				}// if (stop == 0)
				cout << "\x1b[32mВведите числовое значение узла, который Вы будете искать:\x1b[30m ";
				cin >> uzel;       // ввели значение узла, который хотим искать
				// эхо-печать
				cout << "Вы ввели " << uzel << endl;
				cout << "\n\t\t\t\t\t\t \x1b[34m РЕЗУЛЬТАТ ПОИСКА: \x1b[30m \n";
				// вызвали функцию поиска узла в дереве
				Node_search(uzel, Root);
				// распечатали дерево с подкрашиванием элемента, который нашли
				Tree_output_search(Root, level, uzel);
			}// while (true)
			break;

		case 3:                    // выбор удаления элемента из дерева
			// бесконечный цикл удаления узла в дереве
			while (true)
			{
				cout << "\nЕсли вы не хотите больше удалять узлы, введите 0: ";
				cin >> stop;       // флаг остановки введен пользователем
				// если пользователь ввёл 0 - флаг остановки удаления
				if (stop == 0)
				{
					break;         // прервали цикл удаления
				}// if (stop == 0)
				cout << "\x1b[32mВведите числовое значение узла, который Вы будете удалять:\x1b[30m ";
				cin >> uzel;       // ввели значение узла, который хотим удалить
				// эхо-печать
				cout << "Вы ввели " << uzel << endl;
				cout << "\n\t\t\t\t\t\t \x1b[34m РЕЗУЛЬТАТ УДАЛЕНИЯ: \x1b[30m \n";
				// вызвали функцию удаления узла из дерева
				Deleting_a_Node(uzel, Root);
				// распечатали дерево, чтобы посмотреть его вид после удаления
				Tree_output(Root, level);
			}// while (true)
			break;
			                    
		case 4:                    // выбор обхода дерева
			char choice;
			cout << "\nКакой случай Вы хотите рассмотреть для Обхода дерева? Выберете из предложенных:\n\n";
			cout << setw(20) << setfill(' ') << "A) Прямой обход;" << setw(30) << setfill(' ') << "B) Симметричный обход;" << setw(30) << setfill(' ') << "C) Обратный обход;" << endl << endl;
			cout << "Введите A, B, C (Латиницей): ";
			cin >> choice;         // пользователь выбрал,  какой обход будет использовать
			// вызвали функцию прямого обхода дерева
			if (choice == 'A' || choice == 'a')
			{
				cout << "\n\x1b[33mПрямой обход дерева:\x1b[30m ";
				// вызвали функцию прямого обхода дерева
				Tree_traversal_straight(Root);
				cout << endl << endl;
			}//if (choice == 'A' || choice == 'a')
			// вызвали функцию симметричного обхода дерева
			else if (choice == 'B' || choice == 'b')
			{
				cout << "\n\x1b[33mСимметричный обход дерева:\x1b[30m ";
				// вызвали функцию симметричного обхода дерева
				Tree_traversal_symmetric(Root);
				cout << endl << endl;
			}//else if (choice == 'B' || choice == 'b')
			// вызвали функцию обратного обхода дерева
			else if (choice == 'C' || choice == 'c')
			{
				cout << "\n\x1b[33mОбратный обход дерева:\x1b[30m ";
				// вызвали функцию обратного обхода дерева
				Tree_traversal_back(Root);
				cout << endl << endl;
			}//else if (choice == 'C' || choice == 'c')
			// не попали ни в один из случаев
			else
			{
				// выводим сообщение об ошибке
				cout << "\x1b[36mОшибка ввода при выборе типа обхода\x1b[30m \n";
			}//if (choice == 'A' || choice == 'a')
			break;

		case 5:                    // вывод дерева
			cout << "\n\n\t\t\t\t\t\t \x1b[34m ВЫВОД  ДЕРЕВА: \x1b[30m \n";
			// выбор функции вывода дерева
			Tree_output(Root, level);
			break;

		case 6:                    // выбор функции вывода высоты дерева
			// высота принимает значение, полученное из функции
			high = Tree_height(Root);
			// распечатали значение высоты дерева на экран
			cout << "\x1b[32mВысота дерева:\x1b[30m " << high << endl;
			break;

		case 7:                    // выбор функции подсчёта количества узлов в дереве
			// вывели результат функции подсчёта количества узлов в дереве
			cout<< "\x1b[32mКоличество узлов равно:\x1b[30m "<<Number_of_Nodes(Root)<<endl;
			break;

		case 8:                    // выбор функции подсчёта длин путей от корня дерева до очередного чётного элемента
			// вызвали функцию подсчёта путей
			Ways_of_even(Root, dlina, summa_dlin);
			// вывели подсчитанную сумму длин путей от корня дерева до очередного четного его элемента
			cout << "\x1b[32mСумма длин путей от корня до каждого из узлов, содержащих чётные числа:\x1b[30m " << summa_dlin << endl << endl;
			break;

		default:                   // пользователь выбрал Exit, или ошибся
			// завершаем программу по ошибке
			cout << "\n\t\t\t\t\tЗ А В Е Р Ш Е Н И Е   П Р О Г Р А М М Ы \n\n";
			udalenie(pznachenue);        // удалили ранее созданный массив 
			Deliting_a_Tree(Root);       // удалили ранее созданное дерево
			exit(1);                     // закончили программу из функции
	}// switch(vubor)
	return;                              // вернули обещанное значение
}// MENU()


/*-----------------------------------------------------------*/
/*  вставка узла в дерево             */
/*------------------------------------*/
void Node_insertion(int uzel      // число, которое мы хотим добавить в дерево
	              , Node*& Root)  // ссылка на указатель на очередной узел дерева, для изменения дерева
{
	if (!Root)                    // если дошли до места, когда узла ещё нет
	{
		Root = new Node;          // создадим узел
		Root->Data = uzel;        // заполняем его переданным значением
		Root->leftNode = NULL;    // детей у него нет - обнуляем соответствующие указатели
		Root->rightNode = NULL;
		return;                   // вернулись в caller после создания
	}// if (!Root)
	// если узел есть
	else
	{
		if (Root->Data > uzel)    // если его содержимое больше того, которое хотим добавить
		{
			// сдвигваемся в левое поддерево
			Node_insertion(uzel, Root->leftNode);
		}
		// если его содержимое меньше того, которое хотим добавить
		else
		{
			// сдвигваемся в правое поддерево
			Node_insertion(uzel, Root->rightNode);
		}// if (Root->Data > uzel)
	}// if (!Root)
	return;                       // вернулись в caller после отработки функции
}// void Node_insertion()


/*-----------------------------------------------------------*/
/*  поиск узла в дереве               */
/*------------------------------------*/
void Node_search(int uzel         // число, которое мы хотим найти в дереве
	           , Node* Root)      // указатель на очередной узел дерева
{
	if (!Root)                    // узла с таким числовым значением нет в дереве
	{
		cout << "\x1b[31mУзла с таким числовым значением в дереве нет\x1b[30m \n";
		return;                   // вернулись в caller оповещениия
	}// if (!Root)
	
	// Если значение текущего узла меньше, чем то, которое мы ищем
	if (Root->Data < uzel)
	{
		// Перешли в правое поддерево
		Node_search(uzel, Root->rightNode);
	}// if (Root->Data > uzel)
	// если его содержимое больше того, которое мы ищем
	else if (Root->Data > uzel)
	{
		Node_search(uzel, Root->leftNode);
	}//if (Root->Data > uzel)
	// если значение текущего узла совпадает со значением элемента поиска
	else
	{
		// печатаем сам найденный узел и его дочерние элементы
		cout << "\nНашли узел " << Root->Data << endl;;
		cout << "Его дочерние узлы: ";
		// если есть левый потомок - выводим его
		if (Root->leftNode)
		{
			cout<< Root->leftNode->Data;
		}
		// нет левого потомка
		else
		{
			cout << "Левого дочернего узла нет";
		}// if (Root->leftNode)
		cout << " и ";
		// если есть правый потомок - выводим его
		if (Root->rightNode)
		{
			cout<< Root->rightNode->Data;
		}
		// нет правого потомка
		else
		{
			cout << "правого дочернего узла нет\n";
		}// if (Root->rightNode)
		cout << endl;
	}// if (Root->Data > uzel)
	return;                       // вернулись в caller после удачно найденного элемента
}// Node_search()


/*-----------------------------------------------------------*/
/*  удаление узла из дерева               */
/*------------------------------------*/
void Deleting_a_Node(int uzel     // число, которое мы хотим удалить из дерева
	               , Node* Root)  // указатель на очередной узел дерева
{
	Node* parent = NULL;          // узел-родитель текущего узла
	Node* current = Root;         // текущий рассматриваемый узел дерева
	// пока не нашли узел с нужным нам значением
	while (current->Data != uzel)
	{
		parent = current;         // родитель при переходах всегда будет на уровень выше текущего рассматриваемого элемента
		// если значение текущего узла меньше того, которое хотим удалять
		if (current->Data < uzel)
		{
			// сдвигаем текущее значение в правое поддерево
			current = current->rightNode;
		}
		// // если значение текущего узла больше того, которое хотим удалять
		else
		{
			// сдвигаем текущее значение в левое поддерево
			current = current->leftNode;
		}//if (current->Data < uzel)

		// если прошли до конца по нужной ветке, но ток и не нашли элемент, который хотим удалять
		if (!current)
		{
			cout << "\x1b[31mУзла с таким числовым значением в дереве нет. Удалять нечего.\x1b[30m \n";
			return;                // возвращаемся в caller
		}// if (!current)
	}// while (current->Data)
	
    // у найденного элемента удаления нет ни правого, ни левого потомков. Элемент - лист
	if (current->leftNode == NULL && current->rightNode == NULL)
	{
		// если удаляемый узел находится в левом поддереве своего родителя
		if (parent->leftNode == current)
		{
			// обнуляем указатель на левого потомка родителя
			parent->leftNode = NULL;
		}//if (parent->leftNode == current)
		// если удаляемый узел находится в правом поддереве своего родителя
		else if (parent->rightNode == current)
		{
			// обнуляем указатель на правого потомка родителя
			parent->rightNode = NULL;
		}//else if (parent->rightNode == current)
		// Теперь удаляем его
		delete current;
		return;                   // возвращаемся в caller
	}// if (current->leftNode == NULL && current->rightNode == NULL)
	
	// у найденного элемента есть только правое поддерево, но нет левого
	else if (current->leftNode == NULL)
	{
		// подвешиваем его правое поддерево вместо удаляемого узла, если удаляемый элемент находился
		// в левом поддереве своего родителя
		if (parent->leftNode == current)
		{
			// соответственно и правое поддерево удаляемого элемента тоже будет слева от родителя
			parent->leftNode = current->rightNode;
		}// if (parent->leftNode == current)
		// подвешиваем его правое поддерево вместо удаляемого узла, если удаляемый элемент находился
		// в правом поддереве своего родителя
		else if(parent->rightNode == current)
		{
			// соответственно и правое поддерево удаляемого элемента тоже будет справа от родителя
			parent->rightNode = current->rightNode;
		}// else if(parent->rightNode == current)
		// Теперь удаляем его
		delete current;
		return;                   // возвращаемся в caller
	}// else if (current->leftNode == NULL)

	// у найденного элемента есть только левое поддерево, но нет правого
	if (current->rightNode == NULL)
	{
		// подвешиваем его левое поддерево вместо удаляемого узла, если удаляемый элемент находился
		// в левом поддереве своего родителя
		if (parent->leftNode == current)
		{
			// соответственно и левое поддерево удаляемого элемента тоже будет слева от родителя
			parent->leftNode = current->leftNode;
		}// if (parent->leftNode == current)
		// подвешиваем его левое поддерево вместо удаляемого узла, если удаляемый элемент находился
		// в правом поддереве своего родителя
		else if (parent->rightNode == current)
		{
			// соответственно и левое поддерево удаляемого элемента тоже будет справа от родителя
			parent->rightNode = current->leftNode;
		}// else if (parent->rightNode == current)
		delete current;
		// Теперь удаляем его
		return;                   // возвращаемся в caller
	}//i f (current->rightNode == NULL)
	
	// у найденного удаляемого элемента есть и правый и левый потомки
	// на место удаляемого элемента ставим наименьший элемент из его правого поддерева
	Node* replace_right = NULL;  	// для прохода по правому поддереву найденного удаляемого узла
	// изначально его направляем в правое поддерево
	replace_right = current->rightNode;
	// идем по левой части правого поддерева удаляемого элемента
	// идём до момента пока указатель на следующий элемент не будет равен NULL
	while (replace_right->leftNode)
	{
		// запоминаем элемент
		replace_right = replace_right->leftNode;
	}
	int rightData;                  // для запоминания данных нового найденного элемента замены
	// запомнили данные найденного элемента замены
	rightData = replace_right->Data;
	// рекурсивно вызываем функцию, где рассматриваем уже дерево с корнем в элементе current
	Deleting_a_Node(rightData, current);
	// переместили сохранённые данные в новый элемент current
	current->Data = rightData;
	return;                        // возвращаемся в caller
}// Deleting_a_Node()


/*-----------------------------------------------------------*/
/*  удаление всего дерева в целом     */
/*------------------------------------*/
void Deliting_a_Tree(Node* Root)   // указатель на очередной узел дерева
{
	if (Root)                      // если есть узел
	{
		// если есть левый дочерний элемент у данного узла
		if (Root->leftNode)        
		{
			Deliting_a_Tree(Root->leftNode);
		}// if (Root->leftNode)  
		// если есть правый дочерний элемент у данного узла
		if (Root->rightNode)
		{
			Deliting_a_Tree(Root->rightNode);
		}// if (Root->rightNode)
		// удаляем дерево от потомков к предкам поэлементно все узлы
		delete Root;
	}// if (Root)
	return;                        // возвращаемся в caller
}// Deliting_a_Tree()


/*-----------------------------------------------------------*/
/*  функция прямого обхода дерева            */
/*-------------------------------------------*/
void Tree_traversal_straight(Node* Root)  // указатель на очередной узел дерева
{
	// пока есть узел в дереве
	if (Root != NULL)
	{
		// выводим значение
		cout << " " << Root->Data;
		// обращаемся в левое поддерево узла
		Tree_traversal_straight(Root->leftNode);
		// обращаемся в правое поддерево узла
		Tree_traversal_straight(Root->rightNode);
	}// if (Root != NULL)
	return;                               // возвращаемся в caller
}


/*-----------------------------------------------------------*/
/*  функция обратного обхода дерева          */
/*-------------------------------------------*/
void Tree_traversal_back(Node* Root)      // указатель на очередной узел дерева
{
	if (Root != NULL)
	{
	Tree_traversal_back(Root->leftNode);
	// обращаемся в правое поддерево узла
	Tree_traversal_back(Root->rightNode);
	// выводим значение
	cout << " " << Root->Data;
	}// if (Root != NULL)
	return;                               // возвращаемся в caller
}


/*-----------------------------------------------------------*/
/*  функция симметричного обхода дерева      */
/*-------------------------------------------*/
void Tree_traversal_symmetric(Node* Root)    // указатель на очередной узел дерева
{
	// пока есть узел в дереве
	if (Root != NULL)
	{
		// обращаемся в левое поддерево узла
		Tree_traversal_symmetric(Root->leftNode);
		// выводим значение
		cout << " " << Root->Data;
		// обращаемся в правое поддерево узла
		Tree_traversal_symmetric(Root->rightNode);
	}// if (Root != NULL)
	return;                                  // возвращаемся в caller
}// Tree_traversal()


/*-----------------------------------------------------------*/
/*   печать дерева на экран      */
/*-------------------------------*/
void Tree_output(Node* Root        // указатель на очередной узел дерева
	           , int level)        // глубина печати очередного элемента
{
	int i = 0;                     // для цикла вывода пробелов
	// если очередной узел дерева - не нулевой
	if (Root)
	{
		// идём по правому поддереву
		// накапливаем количество отступов глубины
		Tree_output(Root->rightNode, level+1);
		// когда дошли до очередного элемента, у которого правое поддерево равно 0
		// выводим пробелы глубины
		for (i = 0; i < level; i++)
		{
			cout << "    ";
		}// for i
		// и информацию, хранящуюся в данном узле
		cout << Root->Data << endl;
		// идём по левому поддереву
		// накапливаем количество отступов глубины
		Tree_output(Root->leftNode, level+1);
	}// if (Root)
	return;                        // возвращаемся в caller
}// void Tree_output() 


/*-------------------------------------------------------------------------------------------*/
/*  печать дерева после поиска с подсвечиванием элемента, который нашли */
/*----------------------------------------------------------------------*/
void Tree_output_search(Node* Root // указатель на очередной узел дерева
	                  , int level  // глубина печати очередного элемента
	                  , int node)  // узел, который подсвечиваем
{
	int i = 0;                     // для цикла вывода пробелов
	// если очередной узел дерева - не нулевой
	if (Root)
	{
		// идём по правому поддереву
		// накапливаем количество отступов глубины
		Tree_output_search(Root->rightNode, level + 1, node);
		// когда дошли до очередного элемента, у которого правое поддерево равно 0
		// выводим пробелы глубины
		for (i = 0; i < level; i++)
		{
			cout << "    ";
		}// for i
		// если данные выводимого узла равны значению, которое мы ищем
		if (Root->Data == node)
		{
			// выводи элемент, подсветив его красным цветом
			cout << "\x1b[31m"<<Root->Data<< "\x1b[30m" << endl;
		}
		// остальные узлы, не равные значению, которое мы ищем
		else
		{
			// выводим значение узла чёрным цветом
			cout << Root->Data << endl;
		}//if (Root->Data == node)
		// идём по левому поддереву
		// накапливаем количество отступов глубины
		Tree_output_search(Root->leftNode, level + 1, node);
	}// if (Root)
	return;                        // возвращаемся в caller
}// Tree_output_search()


/*-------------------------------------------------------------------------------------------*/
/*  Рекурсивная функция для вычисления высоты заданного бинарного дерева */
/*-----------------------------------------------------------------------*/
int Tree_height(Node* Root)        // указатель на очередной узел дерева

{
	// дошли до конечного узла в поддереве
	if (Root == NULL)
	{
		return 0;                  // возвращаемся в caller
	}// if (Root == NULL)
	// повторяем для левого и правого поддерева и учитываем максимальную глубину
	return 1 + max(Tree_height (Root->leftNode), Tree_height(Root->rightNode));
}// Tree_height()


/*-----------------------------------------------------------*/
/*   подсчёт числа узлов в дереве      */
/*-------------------------------------*/
int Number_of_Nodes(Node* Root)   // указатель на очередной узел дерева
{
	int left;                     // количество узлов левого поддерева
	int right;                    // количество узлов правого поддерева
	// Дошли до листа
	if (Root->leftNode == NULL && Root->rightNode == NULL)
	{
		// вырнулись в caller и поставили left =1  или right =1
		return 1;
	}//if (Root->leftNode == NULL && Root->rightNode == NULL)
	
	// левое поддерево узла не нулевое
	if (Root->leftNode != NULL)
	{
		// число узлов в левом поддереве вычисляется рекуривно из сумм 1 элементов левого и правого поддерева текущего узла
		left = Number_of_Nodes(Root->leftNode);
	}
	// у узла нет левого поддерева
	else
	{
		// количество узлов для него в левом поддереве равно 0
		left = 0;
	}//if (Root->leftNode != NULL)

	// правое поддерево узла не нулевое
	if (Root->rightNode != NULL)
	{
		// число узлов в правом поддереве вычисляется рекуривно из сумм 1 элементов левого и правого поддерева текущего узла
		right = Number_of_Nodes(Root->rightNode);
	}
	// у узла нет правого поддерева
	else
	{
		right = 0;
	}//if (Root->rightNode != NULL)
	return 1 + left + right;       // возвращаемся в caller сумму узлов левого и правого поддерева с учетом корня
}// Number_of_Nodes()


/*-------------------------------------------------------------------------------*/
/*   подсчёт длин путей от корня до очередного чётного элемента   */
/*----------------------------------------------------------------*/
void Ways_of_even(Node* Root       // указатель на очередной узел дерева  
	, int dlina                    // длина пути от корня до очередного чётного элемента
	, int& summa_dlin)             // сумма длин путей от корня до чётных элементов
{
	// Узла не существует
	if (!Root)
	{
		return;                    // возвращаемся в caller
	}//if (!Root)

	// Если иформационная часть узла чётна и он - не корень самого большого дерева
	if (Root->Data % 2 == 0 && dlina!=0)
	{
		// увеличили сумму длин на расстояние от корня до этого элемента
		summa_dlin = summa_dlin + dlina;
		cout<< "Длина пути от корня дерева до " << Root->Data << " = " << dlina << endl;
	}//if (Root->Data % 2 == 0 && dlina!=0)
	// работаем с левым поддеревом данного узла, накапливая расстояние от узла до элемента
	Ways_of_even(Root->leftNode, dlina + 1, summa_dlin);
	// работаем с правым поддеревом данного узла, накапливая расстояние от узла до элемента
	Ways_of_even(Root->rightNode, dlina + 1, summa_dlin);
	return;                       // возвращаемся в caller
}// Ways_of_even()